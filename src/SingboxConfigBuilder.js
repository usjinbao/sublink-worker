import { SING_BOX_CONFIG, generateRuleSets, generateRules, getOutbounds, PREDEFINED_RULE_SETS} from './config.js';
import { BaseConfigBuilder } from './BaseConfigBuilder.js';
import { DeepCopy } from './utils.js';

export class ConfigBuilder extends BaseConfigBuilder {
    constructor(inputString, selectedRules, customRules, pin, baseConfig) {
        if (baseConfig === undefined) {
            baseConfig = SING_BOX_CONFIG
        }
        super(inputString, baseConfig);
        this.selectedRules = selectedRules;
        this.customRules = customRules;
        this.pin = pin;
    }

    addCustomItems(customItems) {
        const validItems = customItems.filter(item => item != null).map(item => {
            if (item.type === 'hysteria2') {
                return {
                    ...item,
                    hop_ports: item.portRange,
                    hop_interval: item.portRange ? "30s" : undefined,
                    hop_ports_policy: item.portRange ? "random" : undefined,
                    tls: {
                        ...item.tls,
                        enabled: true,
                        server_name: item.sni,
                        alpn: ["h3"],
                        insecure: item.skipCertVerify || false  // Ê∑ªÂä†ËØÅ‰π¶È™åËØÅÈÖçÁΩÆ
                    },
                    udp_relay: item.udp ?? true,
                    password: item.password || item.auth  // Á°Æ‰øù auth Â≠óÊÆµÊ≠£Á°Æ‰º†ÈÄí
                };
            }
            return item;
        });
        this.config.outbounds.push(...validItems);
    }

    addSelectors() {
        let outbounds;
        if (typeof this.selectedRules === 'string' && PREDEFINED_RULE_SETS[this.selectedRules]) {
            outbounds = getOutbounds(PREDEFINED_RULE_SETS[this.selectedRules]);
        } else if(this.selectedRules && Object.keys(this.selectedRules).length > 0) {
            outbounds = getOutbounds(this.selectedRules);
        } else {
            outbounds = getOutbounds(PREDEFINED_RULE_SETS.minimal);
        }

        const proxyList = this.config.outbounds.filter(outbound => outbound?.server != undefined).map(outbound => outbound.tag);

        // ÂàõÂª∫È´òÈÄüËäÇÁÇπÂàóË°®ÔºàÂêçÁß∞ÂåÖÂê´ÁâπÂÆöÂÖ≥ÈîÆÂ≠óÁöÑËäÇÁÇπÔºâ
        const highSpeedProxies = proxyList.filter(name => 
            name.includes('F') || 
            name.includes('Ë¥üËΩΩ') || 
            name.includes('È´òÈÄü') ||
            name.includes('‰ºòÈÄâ')
        );
        // Âè™ÊúâÂΩìÂ≠òÂú®Á¨¶ÂêàÊù°‰ª∂ÁöÑËäÇÁÇπÊó∂ÊâçÊ∑ªÂä†Ë¥üËΩΩÂùáË°°ÁªÑ
        if (highSpeedProxies.length > 0) {
            // Ê∑ªÂä†ËΩÆËØ¢Ê®°ÂºèË¥üËΩΩÂùáË°°
            this.config.outbounds.unshift({
                "type": "load_balance",
                "tag": "‚öñÔ∏è Ë¥üËΩΩ-È°∫Â∫è",
                "strategy": "round_robin", // ÈááÁî®‰∏ãÂàíÁ∫øÈ£éÊ†ºÁöÑÁ≠ñÁï•ÂêçÁß∞
                "outbounds": DeepCopy(highSpeedProxies),
                "healthcheck": {
                    "enabled": true, // ÂêØÁî®ÂÅ•Â∫∑Ê£ÄÊü•
                    "url": "http://www.google.com/generate_204",
                    "interval": 300s // Áî®Êï¥Êï∞Ë°®Á§∫Èó¥ÈöîÁßíÊï∞
                }
            });

            // Ê∑ªÂä†Âõ∫ÂÆöËäÇÁÇπË¥üËΩΩÂùáË°°ÔºåËøôÈáåÊòØÊúÄÂ∞ëËøûÊé•Á≠ñÁï•
            this.config.outbounds.unshift({
                "type": "load_balance",
                "tag": "‚öñÔ∏è Ë¥üËΩΩ-‰∏ªÊú∫",
                "strategy": "least_connection",
                "outbounds": DeepCopy(highSpeedProxies),
                "healthcheck": {
                    "enabled": true,
                    "url": "http://www.google.com/generate_204",
                    "interval": 300s
                }
            });
        }

        // Ê∑ªÂä†Ëá™Âä®ÈÄâÊã©ÁªÑ
        this.config.outbounds.unshift({
            type: "urltest",
            tag: "‚ö° Ëá™Âä®ÈÄâÊã©",
            outbounds: DeepCopy(proxyList),
            url: "http://www.google.com/generate_204",
            interval: "300s"
        });

        // Êõ¥Êñ∞‰ª£ÁêÜÂàóË°®
        const balancerGroups = highSpeedProxies.length > 0 ? ['‚öñÔ∏è Ë¥üËΩΩ-È°∫Â∫è', '‚öñÔ∏è Ë¥üËΩΩ-‰∏ªÊú∫'] : [];
        proxyList.unshift('DIRECT', 'REJECT', '‚ö° Ëá™Âä®ÈÄâÊã©', ...balancerGroups);
        outbounds.unshift('üöÄ ËäÇÁÇπÈÄâÊã©','GLOBAL');
        
        outbounds.forEach(outbound => {
            if (outbound !== 'üöÄ ËäÇÁÇπÈÄâÊã©') {
                this.config.outbounds.push({
                    type: "selector",
                    tag: outbound,
                    outbounds: ['üöÄ ËäÇÁÇπÈÄâÊã©', ...proxyList]
                });
            } else {
                this.config.outbounds.unshift({
                    type: "selector",
                    tag: outbound,
                    outbounds: proxyList
                });
            }
        });

        if (Array.isArray(this.customRules)) {
            this.customRules.forEach(rule => {
                this.config.outbounds.push({
                    type: "selector",
                    tag: rule.name,
                    outbounds: ['üöÄ ËäÇÁÇπÈÄâÊã©', ...proxyList]
                });
            });
        }

        this.config.outbounds.push({
            type: "selector",
            tag: "üêü ÊºèÁΩë‰πãÈ±º",
            outbounds: ['üöÄ ËäÇÁÇπÈÄâÊã©', ...proxyList]
        });
    }

    formatConfig() {
        const rules = generateRules(this.selectedRules, this.customRules, this.pin);
        const { site_rule_sets, ip_rule_sets } = generateRuleSets(this.selectedRules,this.customRules);
    
        // ÁßªÈô§ global ÈÖçÁΩÆÔºåÊîπ‰∏∫Âú® experimental ‰∏≠ËÆæÁΩÆ
        this.config.experimental = {
            ...this.config.experimental,
            tcp_connect_timeout: "1s",
            tcp_retry: 5,
            tcp_retry_interval: "1s",
        };
    
        this.config.route.rule_set = [...site_rule_sets, ...ip_rule_sets];

        this.config.route.rules = rules.map(rule => ({
            rule_set: [
              ...(rule.site_rules.length > 0 && rule.site_rules[0] !== '' ? rule.site_rules : []),
              ...(rule.ip_rules.filter(ip => ip.trim() !== '').map(ip => `${ip}-ip`))
            ],
            domain_suffix: rule.domain_suffix,
            domain_keyword: rule.domain_keyword,
            ip_cidr: rule.ip_cidr,
            protocol: rule.protocol,
            outbound: rule.outbound
        }));
        // Add any default rules that should always be present
        this.config.route.rules.unshift(
            { protocol: 'dns', outbound: 'dns-out' },
            { clash_mode: 'direct', outbound: 'DIRECT' },
            { clash_mode: 'global', outbound: 'GLOBAL' }
        );

        this.config.route.auto_detect_interface = true;
        this.config.route.final = 'üêü ÊºèÁΩë‰πãÈ±º';

        return this.config;
    }
}
