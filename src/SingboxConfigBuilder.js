import { SING_BOX_CONFIG, generateRuleSets, generateRules, getOutbounds, PREDEFINED_RULE_SETS} from './config.js';
import { BaseConfigBuilder } from './BaseConfigBuilder.js';
import { DeepCopy } from './utils.js';

export class ConfigBuilder extends BaseConfigBuilder {
    constructor(inputString, selectedRules, customRules, pin, baseConfig) {
        if (baseConfig === undefined) {
            baseConfig = SING_BOX_CONFIG
        }
        super(inputString, baseConfig);
        this.selectedRules = selectedRules;
        this.customRules = customRules;
        this.pin = pin;
    }

    addCustomItems(customItems) {
        const validItems = customItems.filter(item => item != null);
        this.config.outbounds.push(...validItems);
    }

    addSelectors() {
        let outbounds;
        if (typeof this.selectedRules === 'string' && PREDEFINED_RULE_SETS[this.selectedRules]) {
            outbounds = getOutbounds(PREDEFINED_RULE_SETS[this.selectedRules]);
        } else if(this.selectedRules && Object.keys(this.selectedRules).length > 0) {
            outbounds = getOutbounds(this.selectedRules);
        } else {
            outbounds = getOutbounds(PREDEFINED_RULE_SETS.minimal);
        }

        const proxyList = this.config.outbounds.filter(outbound => outbound?.server != undefined).map(outbound => outbound.tag);
        
        // ÂàõÂª∫È´òÈÄüËäÇÁÇπÂàóË°®ÔºàÂêçÁß∞ÂåÖÂê´ÁâπÂÆöÂÖ≥ÈîÆÂ≠óÁöÑËäÇÁÇπÔºâ
        const highSpeedProxies = proxyList.filter(name => 
            name.includes('F') || 
            name.includes('Ë¥üËΩΩ') || 
            name.includes('È´òÈÄü') ||
            name.includes('‰ºòÈÄâ')
        );

        // Âè™ÊúâÂΩìÂ≠òÂú®Á¨¶ÂêàÊù°‰ª∂ÁöÑËäÇÁÇπÊó∂ÊâçÊ∑ªÂä†Ë¥üËΩΩÂùáË°°ÁªÑ
        if (highSpeedProxies.length > 0) {
            // Ê∑ªÂä†ËΩÆËØ¢Ê®°ÂºèË¥üËΩΩÂùáË°°
            this.config.outbounds.unshift({
                type: "load_balance",
                strategy: 'round_robin',
                tag: "‚öñÔ∏è Ë¥üËΩΩ-È°∫Â∫è",
                outbounds: DeepCopy(highSpeedProxies),
                url: "http://www.google.com/generate_204",
                interval: "60s",
                tolerance: 50
            });

            // Ê∑ªÂä†Âõ∫ÂÆöËäÇÁÇπË¥üËΩΩÂùáË°°ÔºàÊ®°Êãü consistent-hashingÔºâ
            this.config.outbounds.unshift({
                type: "load_balance",
                strategy: 'consistent_hashing',
                tag: "‚öñÔ∏è Ë¥üËΩΩ-‰∏ªÊú∫",
                outbounds: DeepCopy(highSpeedProxies),
                url: "http://www.google.com/generate_204",
                interval: "60s",
                tolerance: 50,
                sticky: true  // ‰øùÊåÅËøûÊé•Âõ∫ÂÆöÂà∞Âêå‰∏ÄËäÇÁÇπ
            });
        }

        // Ê∑ªÂä†Ëá™Âä®ÈÄâÊã©ÁªÑ
        this.config.outbounds.unshift({
            type: "urltest",
            tag: "‚ö° Ëá™Âä®ÈÄâÊã©",
            outbounds: DeepCopy(proxyList),
            url: "http://www.google.com/generate_204",
            interval: "300s"
        });

        // Êõ¥Êñ∞‰ª£ÁêÜÂàóË°®
        const balancerGroups = highSpeedProxies.length > 0 ? ['‚öñÔ∏è Ë¥üËΩΩ-È°∫Â∫è', '‚öñÔ∏è Ë¥üËΩΩ-‰∏ªÊú∫'] : [];
        proxyList.unshift('DIRECT', 'REJECT', '‚ö° Ëá™Âä®ÈÄâÊã©', ...balancerGroups);
        outbounds.unshift('üöÄ ËäÇÁÇπÈÄâÊã©','GLOBAL');
        
        outbounds.forEach(outbound => {
            if (outbound !== 'üöÄ ËäÇÁÇπÈÄâÊã©') {
                this.config.outbounds.push({
                    type: "selector",
                    tag: outbound,
                    outbounds: ['üöÄ ËäÇÁÇπÈÄâÊã©', ...proxyList]
                });
            } else {
                this.config.outbounds.unshift({
                    type: "selector",
                    tag: outbound,
                    outbounds: proxyList
                });
            }
        });

        if (Array.isArray(this.customRules)) {
            this.customRules.forEach(rule => {
                this.config.outbounds.push({
                    type: "selector",
                    tag: rule.name,
                    outbounds: ['üöÄ ËäÇÁÇπÈÄâÊã©', ...proxyList]
                });
            });
        }

        this.config.outbounds.push({
            type: "selector",
            tag: "üêü ÊºèÁΩë‰πãÈ±º",
            outbounds: ['üöÄ ËäÇÁÇπÈÄâÊã©', ...proxyList]
        });
    }

    formatConfig() {
        const rules = generateRules(this.selectedRules, this.customRules, this.pin);
        const { site_rule_sets, ip_rule_sets } = generateRuleSets(this.selectedRules,this.customRules);

        this.config.route.rule_set = [...site_rule_sets, ...ip_rule_sets];

        this.config.route.rules = rules.map(rule => ({
            rule_set: [
              ...(rule.site_rules.length > 0 && rule.site_rules[0] !== '' ? rule.site_rules : []),
              ...(rule.ip_rules.filter(ip => ip.trim() !== '').map(ip => `${ip}-ip`))
            ],
            domain_suffix: rule.domain_suffix,
            domain_keyword: rule.domain_keyword,
            ip_cidr: rule.ip_cidr,
            protocol: rule.protocol,
            outbound: rule.outbound
        }));
        // Add any default rules that should always be present
        this.config.route.rules.unshift(
            { protocol: 'dns', outbound: 'dns-out' },
            { clash_mode: 'direct', outbound: 'DIRECT' },
            { clash_mode: 'global', outbound: 'GLOBAL' }
        );

        this.config.route.auto_detect_interface = true;
        this.config.route.final = 'üêü ÊºèÁΩë‰πãÈ±º';

        return this.config;
    }
}